package jitjson

import (
	"bytes"
	"encoding/json"
	"fmt"
	"regexp"
)

var (
	nullRegex   = regexp.MustCompile(`^\s*null\s*$`)
	arrayRegex  = regexp.MustCompile(`^\s*\[\s*(.|\n)*\]\s*$`)
	objectRegex = regexp.MustCompile(`^\s*\{\s*(.|\n)*\}\s*$`)
	boolRegex   = regexp.MustCompile(`^\s*(true|false)\s*$`)
	numberRegex = regexp.MustCompile(`^\s*-?(0|[1-9]\d*)(\.\d+)?([eE][+-]?\d+)?\s*$`)
	stringRegex = regexp.MustCompile(`^\s*"(\\.|[^"\\])*"\s*$`)
)

// ValueType represents the JSON type of the value stored in AnyJitJSON.
// This type is used to determine the type of the value without performing the
// unmarshalling operation.
type ValueType int

// Possible values for AnyJitJSON type assertions.
const (
	TypeNull ValueType = iota
	TypeBool
	TypeNumber
	TypeString
	TypeArray
	TypeObject
	TypeInvalid
)

func (v ValueType) String() string {
	return [...]string{
		"TypeNull",
		"TypeBool",
		"TypeNumber",
		"TypeString",
		"TypeArray",
		"TypeObject",
		"TypeInvalid",
	}[v]
}

// AnyJitJSON can unmarshal arbitrary JSON encodings with just-in-time parsing.
// The value of the encoding can be accessed programmatically by using the methods
// AsBool, AsNumber, AsString, AsArray, and AsObject. // It stores the raw data and
// only unmarshals them when specific values are requested, making it memory efficient
// for large JSON structures where only parts need to be accessed.
//
// Example:
//
//	var any jitjson.AnyJitJSON
//	err := json.Unmarshal([]byte(`{"key": [1, "text", true, null]}`), &any)
//	if err != nil {
//		panic(err)
//	}
//
//	// Access object
//	m, ok := any.AsObject()
//	if !ok {
//		panic("not a map")
//	}
//
//	// Access array value
//	sl, ok := m["key"].AsArray()
//	if !ok {
//		panic("not an array")
//	}
//
//	// Access number value
//	n, ok := sl[0].AsNumber()
//	if !ok {
//		panic("not a number")
//	}
//	fmt.Println(n.Int64()) // Output: 1 <nil>
//
//	// Access string value
//	str, ok := sl[1].AsString()
//	if !ok {
//		panic("not a string")
//	}
//	fmt.Println(s) // Output: text
//
//	// Access boolean value
//	b, ok := sl[2].AsBool()
//	if !ok {
//		panic("not a boolean")
//	}
//	fmt.Println(b) // Output: true
//
//	// Access null value
//	fmt.Println(sl[3].IsNull()) // Output: true
type AnyJitJSON struct {
	val    interface{}
	data   []byte
	parser JSONParser
}

// NewAny creates a new AnyJitJSON from JSON data.
// If the JSON data is invalid, the error is returned.
func NewAny(data []byte) (*AnyJitJSON, error) {
	a := &AnyJitJSON{}
	if !json.Valid(data) {
		return nil, fmt.Errorf("invalid json")
	}
	err := a.UnmarshalJSON(data)
	if err != nil {
		return nil, err
	}
	return a, nil
}

// String returns the JSON encoding of the value with pretty printing.
// If the JSON encoding is invalid, the raw JSON encoding is returned.
//
// Example:
//
//	var jit *jitjson.AnyJitJSON
//	err := json.Unmarshal([]byte(`{"key": "value"}`), &jit)
//	if err != nil {
//		panic(err)
//	}
//	fmt.Println(jit.String()) // Output: { "key": "value" }
func (a *AnyJitJSON) String() string {
	var prettyJSON bytes.Buffer
	err := json.Indent(&prettyJSON, a.data, "", "  ")
	if err != nil {
		return string(a.data)
	}
	return prettyJSON.String()
}

// Parser returns the name of the parser used by AnyJitJSON.
// A parser might be nil when the AnyJitJSON was initialised without a parser.
// In this case, the AnyJitJSON will return "<nil>" which is later set to the default parser.
//
// Example:
//
//	var jit *jitjson.AnyJitJSON
//	fmt.Println(jit.Parser()) // Output: <nil>
//
//	jit = jitjson.NewAny(Person{})
//	fmt.Println(jit.Parser()) // Output: encoding/json
func (a *AnyJitJSON) Parser() string {
	if a.parser == nil {
		return "<nil>"
	} else {
		return a.parser.Name()
	}
}

// SetParser sets the parser to use for the AnyJitJSON.
// Returns an error if the parser is not pre-registered by using [RegisterParser].
func (a *AnyJitJSON) SetParser(name string) error {
	parser, exists := parsers[name]
	if !exists {
		return fmt.Errorf("parser %s not registered", name)
	}
	a.parser = parser
	return nil
}

// Type returns the ValueType of the current AnyJitJSON value. This method can be used
// to determine the type of the underlying value alternatively to type assertion. These
// cover all possible types that can be returned from the Value method:
//
//	var any AnyJitJSON
//	switch any.Type() {
//	case TypeNull:
//	    // handle nil value
//	case TypeBool:
//		b, _ := any.AsBool()
//		// handle boolean value
//	case TypeNumber:
//		num, _ := any.AsNumber()
//		// handle number value
//	case TypeString:
//	    str, _ := any.AsString()
//		// handle string value
//	case TypeArray:
//	    arr, _ := any.AsArray()
//		// handle array value
//	case TypeObject:
//	    obj, _ := any.AsObject()
//		// handle object value
//	case TypeInvalid:
//		panic("invalid type")
//	}
func (a *AnyJitJSON) Type() ValueType {
	if a == nil || a.val == nil {
		return TypeNull
	}
	switch a.val.(type) {
	case *JitJSON[bool]:
		return TypeBool
	case *JitJSON[json.Number]:
		return TypeNumber
	case *JitJSON[string]:
		return TypeString
	case []*AnyJitJSON:
		return TypeArray
	case map[string]*AnyJitJSON:
		return TypeObject
	default:
		return TypeInvalid
	}
}

// IsNull returns true if the AnyJitJSON value is nil.
func (a *AnyJitJSON) IsNull() bool {
	return a.Type() == TypeNull
}

// AsBool returns a bool from AnyJitJSON if possible.
// This method will return false if the value is not a boolean.
func (a *AnyJitJSON) AsBool() (bool, bool) {
	jit, ok := (a.val).(*JitJSON[bool])
	if !ok {
		return false, false
	}
	_ = jit.SetParser(a.parser.Name())
	val, _ := jit.Unmarshal()
	return val, true
}

// AsNumber returns a json.Number from AnyJitJSON if possible.
// This method will return false if the value is not a number.
func (a *AnyJitJSON) AsNumber() (json.Number, bool) {
	jit, ok := (a.val).(*JitJSON[json.Number])
	if !ok {
		return "", false
	}
	_ = jit.SetParser(a.parser.Name())
	val, _ := jit.Unmarshal()
	return val, true
}

// AsString returns a string from AnyJitJSON if possible.
// This method will return false if the value is not a string.
func (a *AnyJitJSON) AsString() (string, bool) {
	jit, ok := (a.val).(*JitJSON[string])
	if !ok {
		return "", false
	}
	_ = jit.SetParser(a.parser.Name())
	val, _ := jit.Unmarshal()
	return val, true
}

// AsArray returns a []*AnyJitJSON from AnyJitJSON if possible.
// This method will return false if the value is not an array.
func (a *AnyJitJSON) AsArray() ([]*AnyJitJSON, bool) {
	if a.data == nil {
		return nil, false
	}
	if _, ok := a.val.([]*AnyJitJSON); !ok {
		return nil, false
	}

	var arr []*AnyJitJSON
	if err := a.parser.Unmarshal(a.data, &arr); err != nil {
		return nil, false
	}

	a.data = nil
	return arr, true
}

// AsObject returns a map[string]*AnyJitJSON from AnyJitJSON if possible.
// This method will return false if the value is not an object.
func (a *AnyJitJSON) AsObject() (map[string]*AnyJitJSON, bool) {
	if a.data == nil {
		return nil, false
	}
	if _, ok := a.val.(map[string]*AnyJitJSON); !ok {
		return nil, false
	}

	var obj map[string]*AnyJitJSON
	if err := a.parser.Unmarshal(a.data, &obj); err != nil {
		return nil, false
	}

	a.data = nil
	return obj, true
}

// MarshalJSON returns the JSON encoding of the value.
func (a *AnyJitJSON) MarshalJSON() ([]byte, error) {
	return a.data, nil
}

// UnmarshalJSON parses the JSON data and stores the value in AnyJitJSON. The method
// supports all valid JSON value types (null, boolean, number, string, array, object).
func (a *AnyJitJSON) UnmarshalJSON(data []byte) error {
	a.val = nil
	a.data = data
	var err error

	// Set default parser
	if a.parser == nil {
		a.parser = getDefaultParser()
	}

	// if the value is null
	if nullRegex.Match(data) {
		a.val = nil
		return nil
	}

	// if the value is a boolean
	if boolRegex.Match(data) {
		var b JitJSON[bool]
		if err = a.parser.Unmarshal(data, &b); err == nil {
			a.val = &b
			return nil
		}
	}

	// if the value is an number
	if numberRegex.Match(data) {
		var num JitJSON[json.Number]
		if err = a.parser.Unmarshal(data, &num); err == nil {
			a.val = &num
			return nil
		}
	}

	// if the value is a string
	if stringRegex.Match(data) {
		var str JitJSON[string]
		if err = a.parser.Unmarshal(data, &str); err == nil {
			a.val = &str
			return nil
		}
	}

	// if the value is an array
	if arrayRegex.Match(data) {
		a.val = []*AnyJitJSON{}
		a.data = make([]byte, len(data))
		copy(a.data, data)
		return nil
	}

	// if the value is an object
	if objectRegex.Match(data) {
		a.val = map[string]*AnyJitJSON{}
		a.data = make([]byte, len(data))
		copy(a.data, data)
		return nil
	}

	return fmt.Errorf("invalid json: %w", err)
}
